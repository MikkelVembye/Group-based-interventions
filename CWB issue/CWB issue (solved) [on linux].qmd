---
title: "CWB issue SOLVED (linux results)"
format: 
  html:
    toc: true
    toc-location: left
execute: 
  echo: true
  warning: false
knitr:
  opts_chunk: 
    fig.pos: "H"
    fig.retina: 2
    cache: FALSE
    R.options:
      knitr.graphics.auto_pdf: true
      width: 100
      knitr.kable.NA: "-"
      dplyr.summarise.inform: FALSE
      scipen: 10
      pillar.sigfig: 4 
editor_options: 
  chunk_output_type: console
---

# Solved prbloem

I just wanted to let you know that we have figured out the problem concerning the diffence between CWB results when `Wald_tets_cwb()` was used in vs. outside a function. The problem was that the object call was not exactly replicated in our function. I provide the soultion below.  

## R packages and data

```{r r-pack-plus-data}
RNGkind("L'Ecuyer-CMRG") # My naive try to steer seed across OS 

library(rlang)
library(tidyverse)
library(metafor)
library(clubSandwich)
library(wildmeta)
library(future)
library(knitr)
library(kableExtra)


mental_health_dat <- 
  readRDS("mental_health_dat.rds") |> 
  mutate(esid = 1:n()) |> 
  select(
    study, esid, N_t, N_c, gt_pop, vgt_pop,
    outcome = analysis_plan, prereg_chr
  )

# Later used to re-construct rma_object$call
attr(mental_health_dat, "data_name") <- "mental_health_dat"

mental_health_dat |> 
  kable(digits=3)  |> 
  kable_styling(
    bootstrap_options = c("striped", "hover"),
    font_size = 10
  ) |> 
  scroll_box(width = "100%", height = "500px", fixed_thead = TRUE)
```

# Fitting models and estimation

## Out-of-function results

```{r cwb-outside-func}
#| eval: true
#| renv.ignore: TRUE

V_mat <- 
  metafor::vcalc(
    vi = vgt_pop, 
    cluster = study, 
    obs = esid, 
    data = mental_health_dat, 
    rho = 0.8
  )

rma_obj <- 
  metafor::rma.mv(
    yi = gt_pop ~ prereg_chr - 1,
    V = V_mat, 
    random = list(~ prereg_chr | study, ~ prereg_chr | esid),
    struct = c("DIAG", "DIAG"),
    data = mental_health_dat,
    sparse=TRUE
  )

rma_obj


n_workers <- max(1L, future::availableCores() - 1L)

future::plan(future::multisession, workers = n_workers)
cwb_obj <- 
  wildmeta::Wald_test_cwb(
    full_model = rma_obj,
    constraints = wildmeta::constrain_equal(1:2),
    R = 19,
    seed = 080725
  ) |> 
  # Supresses the metafor package message when running in parallel 
  suppressPackageStartupMessages() 

plan(sequential) 

#saveRDS(cwb_obj, file = "cwb_res_1999.rds")

cwb_obj
```


## In-function results

```{r cwb-res-from-function}

.arg_tbl <- 
  function(
    yi, vi, covars, r, model, data
  ){
    
    covariates <- if (str_detect(covars, ";")) str_split_1(covars, pattern = ";") else covars 
    
    formula <- reformulate(covariates, response = yi, intercept = FALSE)
    
    if (str_detect(model, "SCE")) {
      
      main_pred <- labels(terms(formula))[1]
      
      outer_form <- 
        substitute(
          ~ moderator | study, 
          list(moderator = as.name(main_pred))
        ) |> 
        as.formula()
      
      inner_form <- 
        substitute(
          ~ moderator | esid, 
          list(moderator = as.name(main_pred))
        ) |> 
        as.formula()
      
      random <-  if (model == "SCEp") list(outer_form, inner_form) else list(outer_form)
      struct <- rep("DIAG", length(random))
      
      res <- 
        tibble(
          formula = list(formula),
          var = vi,
          rand = list(random),
          structure = list(struct),
          rho = r,
          data = list(data)
        )
      
    } else if (model == "CHE") {
      
      res <- 
        tibble(
          formula = list(formula),
          var = vi,
          rand = list(~ 1 | study / esid),
          rho = r,
          data = list(data)
        )
      
    }
    
    res
    
}

# Testing .arg_tbl function
rma_args <- .arg_tbl(
  yi = "gt_pop", 
  vi = "vgt_pop", 
  covars = "prereg_chr", 
  model = "SCEp", 
  r = 0.8,
  data = mental_health_dat
)

# Updated function - recreating rma call
.rma_fun <- function(formula, var, rand, structure, rho, data){
  
  data$vi <- data[[var]]
  data_name <- attr(data, "data_name")
  
  V_mat <- metafor::vcalc(vi = vi, cluster = study, obs = esid, data = data, rho = rho)

  res <- metafor::rma.mv(
    formula,
    V = V_mat, 
    rand = rand,
    struct = structure,
    data = data,
    sparse=TRUE
  )
  
  struct_lang <- str2lang('c("DIAG", "DIAG")')
  random_lang <- paste0("list(", paste0(rand, collapse = ", "), ")") |> str2lang()
  
  res$call <- rlang::call2(
    "rma.mv", 
    yi = formula, 
    V = as.name("V_mat"), 
    data = as.name(data_name), 
    random = random_lang, 
    struct = struct_lang, 
    sparse = TRUE,
    .ns = "metafor"
  )
  
  # Thanks to Rasmus Klokker for providing this solution
  res$call$yi <- as(res$call$yi, Class = "call") 
  
  res
  
}


list_che_res_obj <- pmap(.l = rma_args, .f = .rma_fun)
list_che_res_obj[[1]] 
```

### Equal calls
```{r calls-all-equal}
rma_obj$call
list_che_res_obj[[1]]$call

all.equal(rma_obj$call, list_che_res_obj[[1]]$call)
```

### Wald_test_cwb in function
```{r}
#| eval: true
#| renv.ignore: TRUE
# Quick and dirty function
.Wald_test_cwb_fun <- 
  function(rma_fun_obj, R = 19, seed = 080725){
    

    V_mat <- rma_fun_obj$V
    assign("V_mat", V_mat, envir = .GlobalEnv)
    
    cwb_res <- 
      Wald_test_cwb(
        full_model = rma_fun_obj,
        constraints = constrain_equal(1:2),
        R = R,
        seed = seed
      )
    
    rm(V_mat, envir = .GlobalEnv)
    
    return(cwb_res)
    
}

future::plan(future::multisession, workers = n_workers)
in_fun_res <- map(.x = list_che_res_obj, .f = .Wald_test_cwb_fun) |> list_rbind()
plan(sequential)


in_fun_res
```

# Equal results
After tweaking the call the results now replicate. 
```{r, equal-res}
#| eval: true
c(`In-function CWB p value` = in_fun_res$p_val, `Out-of-function p value` = cwb_obj$p_val)
```


::: {.callout-note icon="false" appearance="simple" title="Session Information" collapse="true"}
```{r}
#| echo: false
ses_info <- sessioninfo::session_info()
ses_info$packages$library <- NULL

ses_info
```
:::
